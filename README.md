# DataStructure

Josephu.cpp
修改后的Josephu问题
编号为1,2,…,n的n个人围坐一圈。约定编号为k(1<=k<=n)的人从1开始，先顺时针报数，数到m的那个人出列；他的下一位（顺时针数）又从1开始，逆时针报数，数到t的那个人出列；他的下一位（逆时针数）又从1开始，顺时针报数，数到m的那个人出列。依次类推，直到所有人出列为止，由此产生一个出队编号的序列。

编程要求：
1、用一个不带头结点的循环双向链表来处理Josephu问题：先构成一个有n个结点的循环双向链表（n次insert），按照规则不断删除结点（remove），直到最后一个结点从链表中删除，算法结束。
2、程序输入：人数n，编号k，计数m和t
3、程序输出：出队编号序列


BracketMatch.cpp
使用栈实现括号匹配问题，从键盘输入一个字符串如：
7-[10-(5-3)+(8+2)*6]
输出其相匹配的括号的位置2 19、6 10、12 16，若含有未能匹配的括号则输出未匹配，并附加输出未匹配括号的位置。


SparseMatrix.cpp
建立基于数组描述的稀疏矩阵，计算两个矩阵相乘的结果并输出；然后将数组描述转换成三元组描述数据结构，重新实现相乘。


InvertBinaryTree.cpp
建立二叉树，根据完全二叉树数组实现数据链式插入，进而实现二叉树中所有结点的左右结点互换，并进行完全二叉树数组形式的输出。例如：
输入：结点数：8，ABCDEF**G***H
输出：ACB*FED**H***G
(*表示空结点)


Post-orderThreadedBinaryTree.cpp
在二叉树基础上，构造后序线索化二叉树，并实现其后序遍历。


Huffman.cpp
假设用于通信的电文是由字符集{a, b, c, d, e, f, g, h}中的字符构成，根据字符在电文中出现的概率，按左子树根结点的权小于等于右子树根结点的权的次序构造霍夫曼树，求出每个字符的霍夫曼编码。
测试数据：字符概率为{0.07, 0.19, 0.02, 0.06, 0.32, 0.03, 0.21, 0.10}


BFS.cpp
通过邻接矩阵表示构建有权无向图，实现对邻接矩阵表示的图做广度优先搜索算法，输出所有顶点。


AdjacentListOfGraph.cpp
通过邻接链表法构建无权有向图，输出图中的所有边对，从该图中删除一个节点，再次输出图中的所有边对。（边对输出顺序不限）
